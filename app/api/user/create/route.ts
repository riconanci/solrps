// app/api/user/create/route.ts - PHASE 2 STEP 2: Wallet User Creation (FIXED PRISMA SCHEMA)
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { z } from 'zod';

const prisma = new PrismaClient();

// Input validation schema
const CreateUserSchema = z.object({
  walletAddress: z.string().min(32).max(44), // Solana wallet address length
  displayName: z.string().optional(),
});

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { walletAddress, displayName } = CreateUserSchema.parse(body);

    console.log(`üéÆ Creating wallet user: ${walletAddress}`);

    // Check if user already exists by wallet address
    const existingUser = await prisma.user.findFirst({
      where: { 
        OR: [
          { walletPubkey: walletAddress },
          { id: walletAddress } // Also check legacy ID field
        ]
      }
    });

    if (existingUser) {
      console.log(`‚úÖ Wallet user already exists: ${walletAddress}`);
      return NextResponse.json({
        success: true,
        user: existingUser,
        message: 'User already exists'
      });
    }

    // Generate unique user ID for wallet users
    const userId = `wallet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const formattedDisplayName = displayName || `Wallet ${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`;

    // Create new wallet user - ONLY using fields that exist in your schema
    const newUser = await prisma.user.create({
      data: {
        id: userId,
        walletPubkey: walletAddress,
        displayName: formattedDisplayName,
        mockBalance: 0, // Starting balance for new users (matches your schema default)
        // createdAt is auto-generated by Prisma @default(now())
        // Note: No updatedAt field in your User model - removed to fix TypeScript error
      }
    });

    console.log(`‚úÖ Created wallet user:`, {
      id: newUser.id,
      walletAddress: newUser.walletPubkey,
      displayName: newUser.displayName,
      balance: newUser.mockBalance,
      createdAt: newUser.createdAt
    });

    return NextResponse.json({
      success: true,
      user: newUser,
      message: 'Wallet user created successfully'
    }, { status: 201 });

  } catch (error) {
    console.error('‚ùå Error creating wallet user:', error);

    if (error instanceof z.ZodError) {
      return NextResponse.json({
        success: false,
        error: 'Invalid input',
        details: error.errors
      }, { status: 400 });
    }

    // More detailed error handling for Prisma errors
    if (error && typeof error === 'object' && 'code' in error) {
      const prismaError = error as any;
      
      if (prismaError.code === 'P2002') {
        return NextResponse.json({
          success: false,
          error: 'User with this wallet address already exists',
          details: 'Duplicate wallet address'
        }, { status: 409 });
      }
      
      if (prismaError.code === 'P2025') {
        return NextResponse.json({
          success: false,
          error: 'Database constraint violation',
          details: prismaError.message
        }, { status: 400 });
      }
    }

    return NextResponse.json({
      success: false,
      error: 'Failed to create wallet user',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const walletAddress = searchParams.get('wallet');

  if (!walletAddress) {
    return NextResponse.json({
      success: false,
      error: 'Wallet address parameter required'
    }, { status: 400 });
  }

  try {
    const user = await prisma.user.findFirst({
      where: { 
        OR: [
          { walletPubkey: walletAddress },
          { id: walletAddress } // Also check legacy ID field
        ]
      }
    });

    if (!user) {
      return NextResponse.json({
        success: false,
        error: 'Wallet user not found'
      }, { status: 404 });
    }

    console.log(`‚úÖ Found wallet user:`, {
      id: user.id,
      walletAddress: user.walletPubkey,
      displayName: user.displayName,
      balance: user.mockBalance
    });

    return NextResponse.json({
      success: true,
      user
    });

  } catch (error) {
    console.error('‚ùå Error fetching wallet user:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to fetch wallet user'
    }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}

// Additional endpoint to check if a wallet address exists
export async function HEAD(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const walletAddress = searchParams.get('wallet');

  if (!walletAddress) {
    return new NextResponse(null, { status: 400 });
  }

  try {
    const user = await prisma.user.findFirst({
      where: { 
        OR: [
          { walletPubkey: walletAddress },
          { id: walletAddress }
        ]
      },
      select: { id: true } // Only select id for performance
    });

    return new NextResponse(null, { 
      status: user ? 200 : 404,
      headers: {
        'X-User-Exists': user ? 'true' : 'false'
      }
    });

  } catch (error) {
    console.error('‚ùå Error checking wallet user:', error);
    return new NextResponse(null, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}

// Helper function to validate Solana addresses
function isValidSolanaAddress(address: string): boolean {
  // Basic Solana address validation
  if (!address || typeof address !== 'string') {
    return false;
  }
  
  // Solana addresses are typically 32-44 characters, base58 encoded
  const solanaAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
  return solanaAddressRegex.test(address);
}

// Batch create multiple wallet users (useful for testing)
export async function PUT(request: NextRequest) {
  try {
    const body = await request.json();
    const { wallets } = body;

    if (!Array.isArray(wallets) || wallets.length === 0) {
      return NextResponse.json({
        success: false,
        error: 'Array of wallet objects required'
      }, { status: 400 });
    }

    const results = [];
    const errors = [];

    for (const wallet of wallets) {
      try {
        const { walletAddress, displayName } = CreateUserSchema.parse(wallet);
        
        // Check if user exists
        const existingUser = await prisma.user.findFirst({
          where: { 
            OR: [
              { walletPubkey: walletAddress },
              { id: walletAddress }
            ]
          }
        });

        if (existingUser) {
          results.push({
            walletAddress,
            status: 'exists',
            user: existingUser
          });
          continue;
        }

        // Create new user
        const userId = `wallet_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newUser = await prisma.user.create({
          data: {
            id: userId,
            walletPubkey: walletAddress,
            displayName: displayName || `Wallet ${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`,
            mockBalance: 500000,
          }
        });

        results.push({
          walletAddress,
          status: 'created',
          user: newUser
        });

      } catch (error) {
        errors.push({
          walletAddress: wallet.walletAddress || 'unknown',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    }

    return NextResponse.json({
      success: true,
      results,
      errors,
      summary: {
        total: wallets.length,
        created: results.filter(r => r.status === 'created').length,
        existing: results.filter(r => r.status === 'exists').length,
        failed: errors.length
      }
    });

  } catch (error) {
    console.error('‚ùå Error batch creating wallet users:', error);
    return NextResponse.json({
      success: false,
      error: 'Failed to batch create wallet users',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  } finally {
    await prisma.$disconnect();
  }
}